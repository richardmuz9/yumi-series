{"version":3,"file":"billingApi-DsX-GX7c.js","sources":["../../src/services/billingApi.ts"],"sourcesContent":["import axios, { AxiosResponse } from 'axios';\nimport { getAuthToken } from '../hooks/useAuth';\nimport { BillingInfo } from '../types/billing';\n\n// Get the environment\nconst isDev = import.meta.env.DEV;\nconst API_BASE = import.meta.env.VITE_API_URL || (import.meta.env.DEV ? 'http://localhost:3000' : 'https://137.184.89.215:3001');\n\nconst billingApi = axios.create({\n  baseURL: API_BASE,\n  withCredentials: true,\n  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': `Bearer ${localStorage.getItem('token')}`,\n    'Has-Cookie-Credentials': 'include'\n  }\n});\n\n// Add request interceptor for logging\nbillingApi.interceptors.request.use(\n  config => {\n    // Log request details in development\n    if (isDev) {\n      console.log('[Billing][Request]', config.method?.toUpperCase(), config.url);\n      console.log('[Billing][Request] URL:', `${API_BASE}${config.url}`);\n      console.log('[Billing][Request] Headers:', config.headers);\n  }\n  return config;\n  },\n  error => {\n    return Promise.reject(error);\n  }\n);\n\n// Add response interceptor for retries\nbillingApi.interceptors.response.use(\n  response => response,\n  async error => {\n    const config = error.config;\n    \n    // Only retry on network errors or 5xx server errors\n    const shouldRetry = (\n      !config.retryCount || \n      config.retryCount < 3\n    ) && (\n      !error.response || \n      (error.response.status >= 500 && error.response.status <= 599)\n    );\n\n    if (shouldRetry) {\n      config.retryCount = (config.retryCount || 0) + 1;\n      const delay = Math.pow(2, config.retryCount - 1) * 500; // Exponential backoff\n      \n      if (isDev) {\n        console.log('[Billing] Request failed (attempt ' + config.retryCount + '/4):', {\n          error: error.message,\n          type: error.response ? 'HTTP' : 'NETWORK',\n          isRetryable: true\n        });\n        console.log('[Billing] Retrying in ' + delay + 'ms...');\n      }\n      \n      await new Promise(resolve => setTimeout(resolve, delay));\n      return billingApi(config);\n    }\n\n    if (isDev) {\n      console.log('[Billing][Error]', config.method?.toUpperCase(), config.url, 'failed:', {\n        error: error.message,\n        type: error.response ? 'HTTP' : 'NETWORK',\n        isRetryable: shouldRetry,\n        retryCount: config.retryCount\n      });\n    }\n\n    return Promise.reject(error);\n  }\n);\n\n// Billing API service for Yumi-Series pricing (3x markup for sustainable business)\nexport interface UserBilling {\n  id: number\n  email: string\n  creditsBalance: number // Credits in USD\n  totalSpent: number\n  qwenTokensUsedMonth: number\n  premiumTokensUsedMonth?: number\n\n  subscriptionStatus: 'active' | 'inactive' | 'canceled' | 'past_due'\n  subscriptionPlan: string\n  monthlyTokensUsed?: number\n  dailyTokensUsed?: number\n  premiumTokens?: number\n  credits: number\n  qwenTokensUsed: number\n  qwenTokensLeft?: number\n  premiumTokensLeft?: number\n\n  nextReset: string\n  nextBillingDate?: string\n}\n\nexport interface CreditPackage {\n  id: string\n  name: string\n  credits: number // USD value\n  price: number // Price in cents\n  description: string\n  recommended: boolean\n}\n\nexport interface SubscriptionPlan {\n  id: string\n  name: string\n  price: number // Price in cents\n  tokensPerDay: number\n  tokensPerMonth: number\n  description: string\n  benefits: string[]\n  interval?: string\n}\n\nexport interface ModelPricing {\n  [provider: string]: {\n    [modelId: string]: {\n      inputCost: number // Cost per 1K tokens (3x markup)\n      outputCost: number // Cost per 1K tokens (3x markup)\n      unit: string\n      dailyLimit?: number\n      monthlyLimit?: number\n    }\n  }\n}\n\nexport interface ModelAvailability {\n  available: boolean\n  isFree: boolean\n  reason: string\n  suggestion?: string\n}\n\nexport interface TokenPackage {\n  id: string;\n  name: string;\n  tokens: number;\n  price: number;\n  currency: string;\n  recommended?: boolean;\n}\n\nexport interface PremiumPlan {\n  id: string;\n  name: string;\n  price: number;\n  currency: string;\n  dailyTokens: number;\n  features: string[];\n}\n\nexport interface UserBillingInfo {\n  stripeCustomerId: string;\n  credits: number;\n  subscription: {\n    status: 'active' | 'inactive' | 'cancelled';\n    plan: 'free' | 'pro';\n    nextBillingDate: string;\n  };\n  freeTokensRemaining?: {\n    openai: number;\n    claude: number;\n    qwen: number;\n  };\n  premiumPlanId?: string;\n  premiumPlanExpiresAt?: string;\n  dailyTokensRemaining?: number;\n}\n\nexport interface PaymentResponse {\n  url: string;\n}\n\ninterface CheckoutResponse {\n  url: string;\n}\n\nexport const getBillingInfo = async (): Promise<BillingInfo> => {\n    try {\n    const response = await billingApi.get('/api/billing/info');\n      return response.data;\n    } catch (error) {\n      console.error('Failed to fetch billing info:', error);\n      throw error;\n    }\n};\n\nexport const createPaymentSession = async (packageId: string): Promise<string> => {\n    try {\n    const response = await billingApi.post('/api/billing/create-session', { packageId });\n    return response.data.sessionId;\n    } catch (error) {\n    console.error('Failed to create payment session:', error);\n      throw error;\n    }\n};\n\nexport const checkPaymentStatus = async (sessionId: string): Promise<boolean> => {\n    try {\n    const response = await billingApi.get(`/api/billing/check-session/${sessionId}`);\n    return response.data.paid;\n    } catch (error) {\n    console.error('Failed to check payment status:', error);\n    throw error;\n    }\n};\n\nexport const getTokenBalance = async (): Promise<number> => {\n    try {\n    const response = await billingApi.get('/api/billing/tokens');\n    return response.data.balance;\n    } catch (error) {\n    console.error('Failed to get token balance:', error);\n    throw error;\n  }\n};\n\nexport const deductTokens = async (amount: number, reason: string): Promise<number> => {\n    try {\n    const response = await billingApi.post('/api/billing/deduct', { amount, reason });\n    return response.data.newBalance;\n    } catch (error) {\n    console.error('Failed to deduct tokens:', error);\n    throw error;\n    }\n};\n\nexport const addTokens = async (amount: number, reason: string): Promise<number> => {\n  try {\n    const response = await billingApi.post('/api/billing/add', { amount, reason });\n    return response.data.newBalance;\n  } catch (error) {\n    console.error('Failed to add tokens:', error);\n    throw error;\n  }\n};\n\nexport default {\n  getBillingInfo,\n  createPaymentSession,\n  checkPaymentStatus,\n  getTokenBalance,\n  deductTokens,\n  addTokens\n}; "],"names":["API_BASE","import","billingApi","axios","create","baseURL","withCredentials","headers","localStorage","getItem","interceptors","request","use","config","error","Promise","reject","response","retryCount","status","delay","Math","pow","resolve","setTimeout","getBillingInfo","get","data","createPaymentSession","packageId","post","sessionId"],"mappings":"wCAMA,MAAMA,EAAWC,+BAEXC,EAAaC,EAAMC,OAAO,CAC9BC,QAASL,EACTM,gBAAiB,GACjBC,QAAS,CACP,eAAgB,mBAChB,cAAiB,UAAUC,aAAaC,QAAQ,OAAO,CAAC,GACxD,yBAA0B,SAAA,CAE9B,CAAC,EAGDP,EAAWQ,aAAaC,QAAQC,IACpBC,GAOHA,EAEEC,GACAC,QAAQC,OAAOF,CAAK,CAE/B,EAGAZ,EAAWQ,aAAaO,SAASL,IACnBK,GAAAA,EACZ,MAAMH,GAAS,CACb,MAAMD,EAASC,EAAMD,OAWrB,IAPE,CAACA,EAAOK,YACRL,EAAOK,WAAa,KAEpB,CAACJ,EAAMG,UACNH,EAAMG,SAASE,QAAU,KAAOL,EAAMG,SAASE,QAAU,KAG3C,CACRD,EAAAA,YAAcL,EAAOK,YAAc,GAAK,EAC/C,MAAME,EAAQC,KAAKC,IAAI,EAAGT,EAAOK,WAAa,CAAC,EAAI,IAWnD,aAAM,IAAIH,QAAQQ,GAAWC,WAAWD,EAASH,CAAK,CAAC,EAChDlB,EAAWW,CAAM,CAAA,CAYnBE,OAAAA,QAAQC,OAAOF,CAAK,CAC7B,CACF,EA4GO,MAAMW,EAAiB,SAAkC,CACxD,GAAA,CAEF,OADe,MAAMvB,EAAWwB,IAAI,mBAAmB,GACvCC,WACTb,EAAO,CACNA,cAAAA,MAAM,gCAAiCA,CAAK,EAC9CA,CAAAA,CAEZ,EAEac,EAAuB,MAAOC,GAAuC,CAC1E,GAAA,CAEJ,OADiB,MAAM3B,EAAW4B,KAAK,8BAA+B,CAAED,UAAAA,CAAAA,CAAW,GACnEF,KAAKI,gBACZjB,EAAO,CACRA,cAAAA,MAAM,oCAAqCA,CAAK,EAChDA,CAAAA,CAEZ"}